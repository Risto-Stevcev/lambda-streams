<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (lambda_streams.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ lambda_streams</nav><nav class="toc"><ul><li><a href="#top">Lambda_streams</a><ul><li><a href="#introduction">Introduction</a></li><li><a href="#generic-streams">Generic Streams</a><ul><li><a href="#behaviors">Behaviors</a></li><li><a href="#sync">Sync</a></li><li><a href="#async">Async</a></li></ul></li><li><a href="#finite-streams">Finite Streams</a><ul><li><a href="#finite.sync">Finite.Sync</a></li><li><a href="#finite.async">Finite.Async</a></li></ul></li><li><a href="#simulating-talkbacks">Simulating Talkbacks</a></li><li><a href="#lwt-and-async-helpers">Lwt and Async Helpers</a></li><li><a href="#javascript-promise-helpers">Javascript Promise Helpers</a></li><li><a href="#differences-from">Differences From</a><ul><li><a href="#rx(js)/most/xstream/kefir">Rx(Js)/Most/Xstream/Kefir</a></li><li><a href="#stream/lwt/async">Stream/Lwt/Async</a></li><li><a href="#wonka">Wonka</a></li><li><a href="#callbag">Callbag</a></li></ul></li><li><a href="#references">References</a></li></ul></li></ul></nav></header><h2 id="top"><a href="#top" class="anchor"></a>Lambda_streams</h2><p><i>Lambda_streams</i> is a streaming library based on using lambdas as a basis for writing simple, composable streams. It's inspired by <a href="https://github.com/callbag/callbag">callbag</a> (see <a href="#differences-from">differences</a>).</p><h3 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h3><p>Lambda streams themselves are simple functions. The types are refined with the <code>private</code> keyword so that they can be distinguished by the type system as being streams. They can be upcast back to their function form with <code>:&gt;</code> or explicitly lowered by constructing them with the <code>make</code> functions.</p><p>For example:</p><ul><li>A <code>unit -&gt; 'a</code> function represents a synchronous input stream.</li><li>A <code>'a -&gt; unit</code> function represents a synchronous output stream.</li><li>A <code>('a -&gt; unit) -&gt; unit</code> function represents an asynchronous input or output stream.</li><li>A <code>{ input: unit -&gt; 'a; close: unit -&gt; unit }</code> record represents a <a href="https://risto-stevcev.github.io/lambda-streams/lambda_streams/Lambda_streams/Connection/index.html#type-t">connection</a>-based synchronous stream.</li></ul><h3 id="generic-streams"><a href="#generic-streams" class="anchor"></a>Generic Streams</h3><h4 id="behaviors"><a href="#behaviors" class="anchor"></a>Behaviors</h4><p>Behaviors<a href="#references"><sup>1</sup></a> are streams that are continuous functions. They always have a current value. <a href="Lambda_streams/Sync/index.html"><code>Lambda_streams.Sync</code></a> streams are synchronous behavior streams. These are useful in modeling things like synchronous IO, (in)finite series, current mouse position, etc.</p><h4 id="sync"><a href="#sync" class="anchor"></a>Sync</h4><p><a href="Lambda_streams/Sync/index.html"><code>Lambda_streams.Sync</code></a> streams</p><p><code>Pull-based</code>, <code>Synchronous</code>, <code>Behaviors</code></p><h4 id="async"><a href="#async" class="anchor"></a>Async</h4><p><a href="Lambda_streams/Async/index.html"><code>Lambda_streams.Async</code></a> streams</p><p><code>Push-based</code>, <code>Asynchronous</code>, <code>Continuations</code></p><h3 id="finite-streams"><a href="#finite-streams" class="anchor"></a>Finite Streams</h3><p>Finite streams are streams that will eventually end. They are modeled with <a href="Lambda_streams/Signal/index.html"><code>Lambda_streams.Signal</code></a>s.</p><h4 id="finite.sync"><a href="#finite.sync" class="anchor"></a>Finite.Sync</h4><p><a href="Lambda_streams/Finite/Sync/index.html"><code>Lambda_streams.Finite.Sync</code></a> streams</p><h4 id="finite.async"><a href="#finite.async" class="anchor"></a>Finite.Async</h4><p><a href="Lambda_streams/Finite/Async/index.html"><code>Lambda_streams.Finite.Async</code></a> streams</p><h3 id="simulating-talkbacks"><a href="#simulating-talkbacks" class="anchor"></a>Simulating Talkbacks</h3><p>Talkback semantics are simulated <i>explicitly</i> with <a href="Lambda_streams/Connection/index.html"><code>Lambda_streams.Connection</code></a>s rather than being baked implicitly into the streams. This makes readable streams much simpler and more predictable.</p><ul><li><p><i>To simulate a talkback</i>, write a function that returns a connection:</p><pre><code class="ml">(** Reads a file line by line *)
val read_file : path:string -&gt; (string Finite.Sync.input, unit Sync.output) Connection.t</code></pre><p>In this case, writing to the output stream would close the file descriptor and end the stream. Subsequent writes to the output stream would just be ignored.</p><p>A simpler alternative function for this use case would be to just close the file descriptor and end the stream at <code>EOF</code>:</p><pre><code class="ml">val read_file : path:string -&gt; string Finite.Sync.input</code></pre></li><li><p><i>To simulate propagating a talkback</i>, write a function that takes and returns a connection:</p><pre><code class="ml">(** Combines two connection-based streams *)
val pair : ('a, unit Sync.output) Connection.t -&gt; ('b, unit Sync.output) Connection.t -&gt; ('a * 'b, unit Sync.output) Connection.t</code></pre><p>In this case, calling the output stream that's returned would call the two output streams that were provided as inputs to the function to close their connections. The side-effects are propagated upstream in an explicit way.</p></li></ul><h3 id="lwt-and-async-helpers"><a href="#lwt-and-async-helpers" class="anchor"></a>Lwt and Async Helpers</h3><ul><li><a href="https://opam.ocaml.org/packages/lwt">Lwt</a> helpers are in the <a href="https://risto-stevcev.github.io/lambda-streams/lambda_streams_lwt"><code>Lambda_streams_lwt</code></a> package.</li><li><a href="https://opam.ocaml.org/packages/async">Async</a> helpers are in the <a href="https://risto-stevcev.github.io/lambda-streams/lambda_streams_async"><code>Lambda_streams_async</code></a> package.</li></ul><h3 id="javascript-promise-helpers"><a href="#javascript-promise-helpers" class="anchor"></a>Javascript Promise Helpers</h3><p>The <a href="https://github.com/Risto-Stevcev/lambda-streams-promise">lambda-streams-promise</a> package provides javascript promise helpers. See the docs <a href="https://risto-stevcev.github.io/lambda-streams-promise">here</a>.</p><h3 id="differences-from"><a href="#differences-from" class="anchor"></a>Differences From</h3><p>There are many streaming libraries out there in many languages, so why yet another one?</p><h4 id="rx(js)/most/xstream/kefir"><a href="#rx(js)/most/xstream/kefir" class="anchor"></a>Rx(Js)/Most/Xstream/Kefir</h4><p>These are older streaming libraries. They're all different from each other, but the main sore point with all of them is that the underlying implementations are relatively complex. This means that subtle differences in behavior can potentially be a real pain to debug and fix and it's not that easy to implement new streams from scratch.</p><h4 id="stream/lwt/async"><a href="#stream/lwt/async" class="anchor"></a>Stream/Lwt/Async</h4><p><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Stream.html">Stream</a> is the builtin Ocaml streaming library. <a href="https://ocsigen.org/lwt/dev/api/Lwt_stream">Lwt</a> and <a href="https://ocaml.janestreet.com/ocaml-core/latest/doc/async_kernel/Async_kernel__/Async_stream">Async</a> streams differ from the builtin library in that they provide direct multi-threading support. All of these are designed for native and they all have support for JS compilation as well.</p><p>These streams are very useful but they run into the same limitations as non-callbag streams: implementations are relatively complex and potentially hard to debug.</p><p>Lwt and Async are still recommended because they provide multi-threading support, which is why <a href="#lwt-and-async-helpers">helpers</a> are provided to convert these to and from lambda streams.</p><h4 id="wonka"><a href="#wonka" class="anchor"></a>Wonka</h4><p>Wonka is a Bucklescript/Reason implementation of callbags. It uses Ocaml's nice algebraic data types instead of JS. The benefit is that it makes the implementations much easier to read and follow compared to callbag's JS implementations. The drawback is that you can't directly leverage already built callbags because they're not compatible with Wonka -- you have to reimplement them in Ocaml. There are direct FFI bindings to callbags with <a href="https://github.com/Risto-Stevcev/bs-callbag">bs-callbag</a> and <a href="https://github.com/Risto-Stevcev/bs-callbag-basics">bs-callbag-basics</a> to address this problem if it's an issue for you. Since these are essentially the same as callbags, they run into the same pitfalls as callbags.</p><h4 id="callbag"><a href="#callbag" class="anchor"></a>Callbag</h4><p>Callbags simplify the notion of a stream into a single async callback function called a callbag. They're nice and intuitive, easy to learn, and it's very easy to build your own callbags. It's very useful for functional programming because you get transducers for free and a <i>mostly</i> purely functional approach to imperative and side-effecting code.</p><p>The downsides are:</p><ul><li><p>The callbag implementation includes/allows talkbacks.</p><p>This can be convenient in some cases, but it's also a major sore point. A callbag using a talkback can have an implicit state associated with it, which makes it's more like an imperative/side-effecting construct than a purely functional one.</p><p>For example, callbags sources that are shared need to be <i>potentially</i> split with <a href="https://github.com/staltz/callbag-share">share</a>. Some callbags would work without it and some won't.</p></li><li>Callbags generalize over multiple different kinds of streams, which makes callbag behavior much harder to predict because it's not explicit. For example, some callbags are <i>pullable</i>, some are <i>listenable</i>, and some callbags only work on one or the other, or both. This leads to a lot of unnecessary complexity.</li><li>Some callbag implementations can be hard to read as a result of the implicit talkbacks and having to deal with callbags that might have talkbacks. This can make debugging and implementing new streams with similar behaviors a pain.</li><li>Callbags are asynchronous by default with implicit push and pull semantics baked in, which means synchronous stream-like constructs are out of the picture, and implementing behavior streams can get awkward.</li></ul><p>Lambda streams were built to address this issue of talkbacks by providing predictable readable streams that can be multicast without worrying about how internal state is managed. This simplifies implementations significantly, since stream authors don't have to worry about managing potential upstream effects with talkbacks. Any situation normally requiring talkbacks is managed <i>explicitly</i> by providing a pair or readable and writable streams called a <a href="Lambda_streams/Connection/index.html"><code>Lambda_streams.Connection</code></a>. Stream authors and end users can then decide directly <a href="#simulating-talkbacks">how to manage</a> connections without it being baked into the readable stream semantics.</p><p>Another difference is that lambda-streams includes other kinds of function streams, such as <a href="Lambda_streams/Sync/index.html"><code>Lambda_streams.Sync</code></a> streams, which are much better suited for <a href="#behaviors">certain tasks</a> like manipulating lists and arrays, or reading data that always has a current value such as the browser viewport's current mouse position.</p><h3 id="references"><a href="#references" class="anchor"></a>References</h3><ol><li>Elliott, Conal (2009), <a href="http://conal.net/papers/push-pull-frp">Push-pull functional reactive programming</a>.</li></ol></div></body></html>